"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("pixi.js");class t extends e.Container{constructor(){super(...arguments),this.layerHeight=0,this.layerWidth=0}}const i={defSpriteAnchor:new e.Point(0,1),debugContainers:!1,usePixiDisplay:!1,roundFontAlpha:!1,injectMiddleware:!0},s={};function r(e){if(!e)return 0;if("number"==typeof e)return e;e=e.length>7?e.substr(3,6):e.substr(1,6);try{return parseInt(e,16)}catch(e){return console.warn("Color parse error:",e.message),0}}var o;function n(e){return e.properties&&e.properties.container?o.DEFAULT:e.gid||e.image?o.IMAGE:null!=e.text?o.TEXT:e.point?o.POINT:e.polygon?o.POLYGON:e.polyline?o.POLYLINE:e.ellipse?o.ELLIPSE:o.DEFAULT}function a(e){let t={};if(e.properties)if(e.properties instanceof Array)for(var i of e.properties){let e=i.value;"color"==i.type&&(e=r(e)),t[i.name]=e}else t=e.properties;const s=e;if(s.gid>0){const e=s.gid,i=!!(1073741824&e),r=!!(2147483648&e),o=!!(536870912&e);t.vFlip=i,t.hFlip=r,t.dFlip=o,s.vFlip=i,s.hFlip=r;const n=536870911&e;s.gid=n}e.parsedProps=t}!function(e){e[e.DEFAULT=0]="DEFAULT",e[e.POINT=1]="POINT",e[e.POLYGON=2]="POLYGON",e[e.POLYLINE=3]="POLYLINE",e[e.ELLIPSE=4]="ELLIPSE",e[e.TEXT=5]="TEXT",e[e.IMAGE=6]="IMAGE"}(o||(o={}));class l extends e.Rectangle{constructor(){super(...arguments),this.name="",this.types=[],this.visible=!0}}class h extends e.Point{constructor(e,t){super(e,t),this.name="",this.types=[],this.visible=!0}}class d extends e.Polygon{constructor(e){super(e),this.name="",this.types=[],this.visible=!0,this._x=0,this._y=0}set x(e){const t=e-this._x;this._x=e;for(let e=0;e<this.points.length;e+=2)this.points[e]+=t}set y(e){const t=e-this._y;this._y=e;for(let e=1;e<this.points.length;e+=2)this.points[e]+=t}get x(){return this._x}get y(){return this._y}getBounds(){let t=new e.Rectangle,i=this._x,s=this._y;for(let e=0;e<this.points.length;e+=2){const r=this.points[e],o=this.points[e+1];t.x=r<t.x?r:t.x,t.y=o<t.y?o:t.y,i=r>i?r:i,s=o>s?o:s}return t.width=i-t.x,t.height=s-t.y,t}get width(){return this.getBounds().width}get height(){return this.getBounds().height}set height(e){const t=e/this.height;for(let e=1;e<this.points.length;e+=2){const i=(this.points[e]-this._y)*t;this.points[e]=this._y+i}}set width(e){const t=e/this.width;for(let e=0;e<this.points.length;e+=2){const i=(this.points[e]-this._x)*t;this.points[e]=this._x+i}}}class c{constructor(e){this.name="",this.types=[],this.visible=!0,this.points=[],this.points=e.slice()}}class p extends e.Ellipse{constructor(e,t,i,s){super(e,t,i,s),this.name="",this.types=[],this.visible=!0}}function u(t){if(!t)return;let i=void 0;const s=n(t);switch(t.x=t.x||0,t.y=t.y||0,s){case o.ELLIPSE:i=new p(t.x+.5*t.width,t.y+.5*t.height,.5*t.width,.5*t.height);break;case o.POLYGON:{const s=t.polygon.map(i=>new e.Point(i.x+t.x,i.y+t.y));i=new d(s);break}case o.POLYLINE:{const s=t.polygon.map(i=>new e.Point(i.x+t.x,i.y+t.y));i=new c(s);break}default:i=new l(t.x,t.y,t.width,t.height)}return i.types=t.type?t.type.split(":"):[],i.visible=t.visible,i.name=t.name,i}var g=Object.freeze({__proto__:null,TiledRect:l,TiledPoint:h,TiledPolygon:d,TiledPolypine:c,TiledEllipse:p,BuildPrimitive:u});class y extends e.Sprite{}function f(t,s){s.name=t.name,s.tiledId=t.id,s.width=t.width||s.width,s.height=t.height||s.height,s.rotation=(t.rotation||0)*Math.PI/180,s.x=t.x||0,s.y=t.y||0,s.visible=null==t.visible||t.visible,s.types=t.type?t.type.split(":"):[],s.primitive=u(t);const r=t.parsedProps;r&&(isNaN(r.opacity)||(s.alpha=Number(r.opacity)),Object.assign(s,r),s.properties=r),s.source=t,i.debugContainers&&setTimeout(()=>{const i=new e.Graphics;i.lineStyle(2,16711680,.7).drawRect(s.x,s.y,t.width,t.height).endFill(),s instanceof e.Sprite&&(i.y-=s.height),s.parent.addChild(i)},30)}function m(s){let r=void 0;return r=(s.type?s.type.split(":"):[]).indexOf("mask")>-1?new y(e.Texture.WHITE):new t,s.gid&&(r instanceof e.Sprite?r.anchor=i.defSpriteAnchor:(r.pivot=i.defSpriteAnchor,r.hitArea=new e.Rectangle(0,0,s.width,s.height))),f(s,r),r}var x=Object.freeze({__proto__:null,ApplyMeta:f,Build:m});function w(t){let s;if(t.image.animation){s=new e.AnimatedSprite(t.image.animation,!!t.parsedProps.autoUpdate||!0);const i=s;i.play&&t.parsedProps.animPlaying&&i.play(),i.loop=void 0===t.parsedProps.animLoop||t.parsedProps.animLoop}else s=new e.Sprite(t.image.texture||e.Texture.EMPTY);s.tileFrame=t.image,t.fromImageLayer||(s.anchor=i.defSpriteAnchor),f(t,s);const r=t.image.objectgroup;r&&(s.primitive=u(r.objects[0]));const o=t.hFlip,n=t.vFlip;return o&&(s.scale.x*=-1,s.anchor.x=1),n&&(s.scale.y*=-1,s.anchor.y=0),s}var T=Object.freeze({__proto__:null,Build:w});function b(s){const o=new t,n=s.text;let a=new e.Text(n.text,{wordWrap:n.wrap,wordWrapWidth:s.width,fill:r(n.color||"#000000")||0,align:n.valign||"top",fontFamily:n.fontfamily||"sans-serif",fontWeight:n.bold?"bold":"normal",fontStyle:n.italic?"italic":"normal",fontSize:n.pixelsize||"16px"});a.name=s.name+"_Text",a.roundPixels=!!i.roundFontAlpha;const l=s.parsedProps;switch(s.properties=[],s.parsedProps={},f(s,o),o.pivot.set(0,0),n.halign){case"right":a.anchor.x=1,a.position.x=s.width;break;case"center":a.anchor.x=.5,a.position.x=.5*s.width;break;default:a.anchor.x=0,a.position.x=0}switch(n.valign){case"bottom":a.anchor.y=1,a.position.y=s.height;break;case"center":a.anchor.y=.5,a.position.y=.5*s.height;break;default:a.anchor.y=0,a.position.y=0}return l&&(a.style.stroke=r(l.strokeColor)||0,a.style.strokeThickness=l.strokeThickness||0,a.style.padding=l.fontPadding||0,Object.assign(a,l)),o.addChild(a),o.text=a,o.properties=l,o}var P=Object.freeze({__proto__:null,Build:b});class _{constructor(e){this.sheets=[],this.images={},e&&e.forEach(e=>{this.add(e)})}add(e){if(!e)throw"Sheet can't be undefined";if(e===this)throw"U can't add self to spritesheet";this.sheets.push(e)}addTexture(e,t){this.images[t]=e}get textures(){let e={};for(const t of this.sheets)Object.assign(e,t.textures);return Object.assign(e,this.images),e}get animations(){let e={};for(const t of this.sheets)Object.assign(e,t.animations);return e}}class I extends e.resources.ImageResource{load(){return new Promise((e,t)=>{const i={onError:t};this.onError.add(i),super.load().then(e)})}}class v extends e.utils.EventEmitter{constructor(e,t){super(),this._tileSets=e,this._sheet=new _,this._loadQueue=0,this.baseUrl="",this.loadUnknowImages=!0,t&&(t.textures?this.register(t):Object.keys(t).forEach(e=>{this._sheet.addTexture(t[e],e)}))}register(e){this._sheet.add(e)}get spritesheet(){return this._sheet}getTileByGid(e,t=this.loadUnknowImages){const i=function(e,t,i){let s=void 0,r=0;for(let t=0;t<e.length;t++)if(e[t].firstgid<=i){s=e[t],r=t;break}if(!s)return console.error("Image with gid:"+i+" not found!"),null;const o=i-s.firstgid;let n=s.tiles.filter(e=>e.id==o)[0],a=Object.assign({},n,{tilesetId:r});return a||(console.error("Load res MISSED gid:"+o),null)}(this._tileSets,this.baseUrl,e);return this.getTileByTile(i,t)}getTileByTile(e,t=this.loadUnknowImages,i=!1){if(!e||!e.image)return;if(e.animation&&!i){const i=this._tileSets[e.tilesetId];e.animation.forEach(e=>{e.texture=this.getTileByTile(i.tiles[e.tileid],t,!0).texture,e.time=e.duration})}const s=this.baseUrl+e.image;let r=this.spritesheet.textures[e.image];return e.lazyLoad=!1,!r&&t&&(r=this._tryLoadTexture(s,e),e.lazyLoad=!0,this._sheet.addTexture(r,e.image)),e.texture=r,e}_tryLoadTexture(t,i){const s=new I(t,{autoLoad:!1,crossorigin:"anonymous"}),r=new e.Texture(new e.BaseTexture(s));return e.Texture.addToCache(r,t),this._loadQueue++,s.load().then(()=>{r.emit("loaded")}).catch(e=>{console.warn("Tile set image loading error!",i)}).finally(()=>{this._loadQueue--,0===this._loadQueue&&(this.emit("loaded"),console.log("loaded"))}),r}get loaded(){return this._loadQueue<=0}}class L extends t{}let E=!0;function O(e,t,r=""){if(!t||"map"!=t.type)return;E&&(console.log("[TILED] Importer!\neXponenta {rondo.devil[a]gmail.com}"),E=!1);const o=!!i.usePixiDisplay&&void 0!==PIXI.display,n=new L;if(n.layerHeight=t.height,n.layerWidth=t.width,n.source=t,n.tileSet=new v(t.tilesets,e),n.tileSet.baseUrl=r,t.layers){let e=0;o&&(t.layers=t.layers.reverse());for(let i of t.layers){const t=s[i.type];if(!t){console.warn(`[TILED] Importer can't support ${i.type} layer type!`);continue}const r=t.Build(i,n.tileSet,e);r&&(e++,n.layers={[i.name]:r},n.addChild(r))}}return n}const S={Parse(e,t){const i=e.data,s=new RegExp(/^.*[\\\/]/);let r=e.url.replace(this.baseUrl,"");r=r.match(s)[0];const o=O(e.textures,i,r);o?(o.name=e.url.replace(s,"").split(".")[0],e.stage=o,o.tileSet.loaded?t():o.tileSet.once("loaded",()=>t())):t()},use(e,t){S.Parse.call(this,e,t)},add(){console.log("[TILED] middleware registered!")}};function j(t){!function(t){if(!t.Container)throw new Error("Cant't find Container in package!");e.Container.prototype.getChildByPath=function(e){if(!this.children||0==this.children.length)return;let t=this;const i=e.split("/"),s=new RegExp("(?:{{0})-?d+(?=})");for(const e of i){if(null==t||!t.children){t=void 0;break}if(0==e.trim().length)continue;const i=t.children,r=e.match(s);if(r){let e=parseInt(r[0]);e<0&&(e+=i.length),t=e>=i.length?void 0:i[e]}else t=t.getChildByName(e)}return t},e.Container.prototype.addGlobalChild=function(...t){this.transform.updateLocalTransform();const i=new e.Matrix,s=this.transform.localTransform.clone().invert();for(let e=0;e<t.length;e++){const r=t[e];r.transform.updateLocalTransform(),i.copyFrom(s),i.append(r.localTransform),t[e].transform.setFromMatrix(i)}return this.addChild(...t)}}(t),function(e){if(!e.DisplayObject)throw new Error("Cant't find DisplayObject in package!");e.DisplayObject.prototype.replaceWithTransform=function(e){e.updateTransform(),e.parent&&e.parent.addChildAt(this,e.parent.getChildIndex(e)),this.pivot.copyFrom(e.pivot),this.position.copyFrom(e.position),this.scale.copyFrom(e.scale),this.rotation=e.rotation,this.updateTransform()}}(t),function(e){if(!e.utils)throw new Error("Cant't find utils in package!");e.utils.EventEmitter.prototype.onceAsync=function(e,t){return new Promise(i=>{this.once(e,i,t)})}}(t)}const C={Build(e,s,r=0){const o=!!i.usePixiDisplay&&void 0!==PIXI.display,n=o?PIXI.display.Layer:{},l=o?PIXI.display.Group:{};a(e);const h=e.parsedProps;if(h.ignore||h.ignoreLoad)return void console.log("[TILED] layer ignored:"+e.name);const d=o?new n(new l(void 0!==h.zOrder?h.zOrder:r,!0)):new t;return d.tiledId=e.id,d.name=e.name,d.visible=e.visible,d.position.set(e.x,e.y),d.alpha=e.opacity||1,f(e,d),d}},k={__gen:{[o.IMAGE](e,t){const i=e,s=i.image?t.getTileByTile(i.image):t.getTileByGid(i.gid);i.image=s;const r=w(i);return i.fromImageLayer&&s.lazyLoad&&s.texture.once("loaded",()=>{r.scale.set(1)}),i.fromImageLayer&&r.anchor.set(0),r},[o.TEXT]:(e,t)=>b(e),[o.DEFAULT]:(e,t)=>m(e)},Build(e,t,i=0){const s=e,r=C.Build(e,t,i);if(!r)return;if("imagelayer"===e.type&&!this.__convertLayer(e))return;if(!s.objects||!s.objects.length)return r;const l=s.objects;let h=0;for(let e of l){a(e);const i=n(e),s=(this.__gen[i]||this.__gen[o.DEFAULT]).call(this,e,t);s&&(r.addChildAt(s,h),h++)}return r},__convertLayer:e=>!!e.image&&(e.objects=[{image:{image:e.image},gid:-1,name:e.name,x:e.x+e.offsetx,y:e.y+e.offsety,fromImageLayer:!0,properties:e.properties,parsedProps:e.parsedProps}],!0)};Object.assign(s,{tilelayer:void 0,objectgroup:k,imagelayer:k,group:void 0}),exports.Config=i,exports.ContainerBuilder=x,exports.CreateStage=O,exports.Inject=function(e=window.PIXI,t){e?(t&&Object.assign(i,t),j(e),i.injectMiddleware&&e.Loader.registerPlugin(S)):console.warn("Auto injection works only with globals scoped PIXI, not in modules\nuse 'Loader.registerPlugin(Parser)' otherwith")},exports.MultiSpritesheet=_,exports.Parser=S,exports.Primitives=g,exports.SpriteBuilder=T,exports.TextBuilder=P,exports.TiledContainer=t,exports.VERSION="1.1.13";
//# sourceMappingURL=index.cjs.js.map
